<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>Binary Cam Translator (Simple)</title>
  <style>
    html, body { margin:0; height:100%; background:#000; overflow:hidden; }
    .wrap { position:relative; width:100vw; height:100vh; }
    video { position:absolute; inset:0; width:100%; height:100%; object-fit:cover; }
    canvas { position:absolute; inset:0; width:100%; height:100%; pointer-events:none; }

    .start {
      position:absolute; inset:0; display:flex; align-items:center; justify-content:center;
      background:rgba(0,0,0,0.55); color:#eaeaea;
      font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial;
      text-align:center; padding:24px;
    }
    .start button{
      background:#1f1f1f; border:1px solid #3a3a3a; color:#eaeaea;
      border-radius:14px; padding:12px 16px; font-size:16px; cursor:pointer;
    }
    .start p{ margin:10px 0 0; opacity:.8; font-size:13px; line-height:1.35; }
  </style>
</head>
<body>
<div class="wrap">
  <video id="video" autoplay playsinline muted></video>
  <canvas id="ui"></canvas>

  <div id="startOverlay" class="start">
    <div>
      <button id="btnStart">Toca para iniciar la cámara</button>
      <p>
        Coloca el binario dentro del cuadro.<br>
        La traducción aparece debajo.
      </p>
    </div>
  </div>
</div>

<script src="https://cdn.jsdelivr.net/npm/tesseract.js@5/dist/tesseract.min.js"></script>
<script>
  // ===== Ajustes (puedes tocarlos) =====
  const ROI = {
    wPct: 0.92,      // ancho del cuadro (92% del ancho pantalla)
    hPct: 0.28,      // alto del cuadro
    yCenterPct: 0.45 // posición vertical del centro (0.5 es el centro)
  };

  const SCAN_INTERVAL_MS = 1100; // cada cuánto intenta leer (ms)

  // ===== Colores =====
  const GREEN = "rgba(0,255,120,0.92)";
  const GREEN_SOFT = "rgba(0,255,120,0.55)";

  // ===== Elementos =====
  const video = document.getElementById('video');
  const ui = document.getElementById('ui');
  const ctx = ui.getContext('2d');

  // Offscreen: pintamos el vídeo EXACTAMENTE como se ve (cover)
  const frame = document.createElement('canvas');
  const fctx = frame.getContext('2d', { willReadFrequently:true });

  const btnStart = document.getElementById('btnStart');
  const startOverlay = document.getElementById('startOverlay');

  let stream = null;
  let worker = null;
  let timer = null;
  let busy = false;

  function resize() {
    ui.width = window.innerWidth;
    ui.height = window.innerHeight;
    frame.width = window.innerWidth;
    frame.height = window.innerHeight;
    drawUI("…", "BIN: ");
  }
  window.addEventListener('resize', resize);
  resize();

  function roiRect() {
    const w = Math.floor(ui.width * ROI.wPct);
    const h = Math.floor(ui.height * ROI.hPct);
    const x = Math.floor((ui.width - w) / 2);
    const y = Math.floor(ui.height * ROI.yCenterPct - h / 2);
    return { x, y, w, h };
  }

  function roundRect(c, x, y, w, h, r) {
    const rr = Math.min(r, w/2, h/2);
    c.beginPath();
    c.moveTo(x+rr, y);
    c.arcTo(x+w, y, x+w, y+h, rr);
    c.arcTo(x+w, y+h, x, y+h, rr);
    c.arcTo(x, y+h, x, y, rr);
    c.arcTo(x, y, x+w, y, rr);
    c.closePath();
  }

  // Dibuja vídeo en frame con “cover” (igual que CSS object-fit: cover)
  function drawVideoCoverToFrame() {
    const sw = frame.width, sh = frame.height;
    const vw = video.videoWidth, vh = video.videoHeight;
    if (!vw || !vh) return false;

    const scale = Math.max(sw / vw, sh / vh);
    const dw = vw * scale;
    const dh = vh * scale;
    const dx = (sw - dw) / 2;
    const dy = (sh - dh) / 2;

    fctx.clearRect(0,0,sw,sh);
    fctx.drawImage(video, dx, dy, dw, dh);
    return true;
  }

  // Interfaz: cuadro + traducción debajo + (debug) binario leído
  function drawUI(text, rawBinLine) {
    ctx.clearRect(0,0,ui.width,ui.height);

    const {x,y,w,h} = roiRect();

    // Marco siempre verde
    ctx.lineWidth = 3;
    ctx.strokeStyle = GREEN;
    ctx.strokeRect(x, y, w, h);

    // esquinas tipo escáner
    const c = 18;
    ctx.lineWidth = 5;
    ctx.strokeStyle = GREEN;
    // TL
    ctx.beginPath(); ctx.moveTo(x, y+c); ctx.lineTo(x, y); ctx.lineTo(x+c, y); ctx.stroke();
    // TR
    ctx.beginPath(); ctx.moveTo(x+w-c, y); ctx.lineTo(x+w, y); ctx.lineTo(x+w, y+c); ctx.stroke();
    // BL
    ctx.beginPath(); ctx.moveTo(x, y+h-c); ctx.lineTo(x, y+h); ctx.lineTo(x+c, y+h); ctx.stroke();
    // BR
    ctx.beginPath(); ctx.moveTo(x+w-c, y+h); ctx.lineTo(x+w, y+h); ctx.lineTo(x+w, y+h-c); ctx.stroke();

    // Caja de texto debajo (2 líneas)
    const boxY = y + h + 12;
    const boxH = 76;

    ctx.fillStyle = "rgba(0,0,0,0.45)";
    ctx.strokeStyle = GREEN_SOFT;
    ctx.lineWidth = 2;
    roundRect(ctx, x, boxY, w, boxH, 12);
    ctx.fill(); ctx.stroke();

    // Traducción
    ctx.font = '28px ui-monospace, Menlo, Consolas, monospace';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'top';
    ctx.fillStyle = GREEN;
    ctx.shadowColor = 'rgba(0,0,0,0.75)';
    ctx.shadowBlur = 8;

    ctx.fillText(text && text.length ? text : "…", x + w/2, boxY + 8);

    // Debug: qué binario cree leer
    ctx.font = '14px ui-monospace, Menlo, Consolas, monospace';
    ctx.fillStyle = "rgba(0,255,120,0.72)";
    ctx.fillText(rawBinLine || "", x + w/2, boxY + 44);

    ctx.shadowBlur = 0;
  }

  function cleanBinary(raw) {
    return (raw || "")
      .replace(/[oO]/g,'0')
      .replace(/[iIlL]/g,'1')
      .replace(/[^01 ]/g,'')
      .replace(/\s+/g,' ')
      .trim();
  }

  function binaryToAscii(bin) {
    const bits = bin.replace(/\s+/g,'');
    let out = '';
    for (let i=0; i+8<=bits.length; i+=8) {
      const byte = bits.slice(i, i+8);
      const code = parseInt(byte,2);
      if (code === 32) out += ' ';
      else if (code >= 33 && code <= 126) out += String.fromCharCode(code);
    }
    return out.trim();
  }

  async function initOCR() {
    worker = await Tesseract.createWorker();
    await worker.loadLanguage('eng');
    await worker.initialize('eng');
    await worker.setParameters({
      tessedit_char_whitelist: '01 ',
      preserve_interword_spaces: '1'
    });
  }

  async function scanOnce() {
    if (!stream || busy) return;
    if (!video.videoWidth) return;

    busy = true;
    try {
      const okFrame = drawVideoCoverToFrame();
      if (!okFrame) { busy = false; return; }

      const {x,y,w,h} = roiRect();

      // Recorte ROI a canvas pequeño
      const roi = document.createElement('canvas');
      roi.width = w; roi.height = h;
      roi.getContext('2d', { willReadFrequently:true }).drawImage(frame, x, y, w, h, 0, 0, w, h);

      // OCR directo (sin umbral agresivo)
      const { data } = await worker.recognize(roi);

      const bin = cleanBinary(data.text);
      const txt = binaryToAscii(bin);

      drawUI(txt || "…", bin ? ("BIN: " + bin) : "BIN: (vacío)");

    } catch (e) {
      drawUI("…", "BIN: (error)");
    } finally {
      busy = false;
    }
  }

  async function start() {
    stream = await navigator.mediaDevices.getUserMedia({
      video: { facingMode: { ideal:"environment" }, width:{ideal:1280}, height:{ideal:720} },
      audio:false
    });
    video.srcObject = stream;

    if (!worker) await initOCR();

    startOverlay.style.display = "none";
    drawUI("…", "BIN: ");

    if (timer) clearInterval(timer);
    timer = setInterval(scanOnce, SCAN_INTERVAL_MS);
  }

  btnStart.addEventListener('click', start);
</script>
</body>
</html>
