<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>Binary Cam Translator (mínimo FIX)</title>
  <style>
    html, body { margin:0; height:100%; background:#000; overflow:hidden; }
    .wrap { position:relative; width:100vw; height:100vh; }
    video { position:absolute; inset:0; width:100%; height:100%; object-fit:cover; }
    canvas { position:absolute; inset:0; width:100%; height:100%; pointer-events:none; }
    .start {
      position:absolute; inset:0; display:flex; align-items:center; justify-content:center;
      background:rgba(0,0,0,0.55); color:#eaeaea;
      font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial; text-align:center; padding:24px;
    }
    .start button{
      background:#1f1f1f; border:1px solid #3a3a3a; color:#eaeaea;
      border-radius:14px; padding:12px 16px; font-size:16px; cursor:pointer;
    }
    .start p{ margin:10px 0 0; opacity:.8; font-size:13px; }
  </style>
</head>
<body>
<div class="wrap">
  <video id="video" autoplay playsinline muted></video>
  <canvas id="ui"></canvas>

  <div id="startOverlay" class="start">
    <div>
      <button id="btnStart">Toca para iniciar la cámara</button>
      <p>Coloca el binario dentro del cuadro. La traducción aparecerá debajo.</p>
    </div>
  </div>
</div>

<script src="https://cdn.jsdelivr.net/npm/tesseract.js@5/dist/tesseract.min.js"></script>
<script>
  // Ajustes
  const ROI = { wPct: 0.88, hPct: 0.24, yCenterPct: 0.42 };
  const SCAN_INTERVAL_MS = 1100;
  const MIN_BITS = 16; // más permisivo (antes 24)

  const GREEN = "rgba(0,255,120,0.92)";
  const GREEN_SOFT = "rgba(0,255,120,0.55)";
  const AMBER = "rgba(255,190,90,0.9)";

  const video = document.getElementById('video');
  const ui = document.getElementById('ui');
  const ctx = ui.getContext('2d');
  const btnStart = document.getElementById('btnStart');
  const startOverlay = document.getElementById('startOverlay');

  // Offscreen: aquí pintamos el vídeo EXACTAMENTE como se ve (cover)
  const frame = document.createElement('canvas');
  const fctx = frame.getContext('2d', { willReadFrequently:true });

  let stream = null;
  let worker = null;
  let timer = null;
  let busy = false;

  function resize() {
    ui.width = window.innerWidth;
    ui.height = window.innerHeight;
    frame.width = window.innerWidth;
    frame.height = window.innerHeight;
    drawUI("…", true);
  }
  window.addEventListener('resize', resize);
  resize();

  function roiRect() {
    const w = Math.floor(ui.width * ROI.wPct);
    const h = Math.floor(ui.height * ROI.hPct);
    const x = Math.floor((ui.width - w) / 2);
    const y = Math.floor(ui.height * ROI.yCenterPct - h / 2);
    return { x, y, w, h };
  }

  function roundRect(c, x, y, w, h, r) {
    const rr = Math.min(r, w/2, h/2);
    c.beginPath();
    c.moveTo(x+rr, y);
    c.arcTo(x+w, y, x+w, y+h, rr);
    c.arcTo(x+w, y+h, x, y+h, rr);
    c.arcTo(x, y+h, x, y, rr);
    c.arcTo(x, y, x+w, y, rr);
    c.closePath();
  }

  function drawUI(text, ok=true) {
    ctx.clearRect(0,0,ui.width,ui.height);
    const {x,y,w,h} = roiRect();

    ctx.lineWidth = 3;
    ctx.strokeStyle = ok ? GREEN : AMBER;
    ctx.strokeRect(x, y, w, h);

    // esquinas
    const c = 18;
    ctx.lineWidth = 5;
    ctx.strokeStyle = ok ? GREEN : AMBER;
    // TL
    ctx.beginPath(); ctx.moveTo(x, y+c); ctx.lineTo(x, y); ctx.lineTo(x+c, y); ctx.stroke();
    // TR
    ctx.beginPath(); ctx.moveTo(x+w-c, y); ctx.lineTo(x+w, y); ctx.lineTo(x+w, y+c); ctx.stroke();
    // BL
    ctx.beginPath(); ctx.moveTo(x, y+h-c); ctx.lineTo(x, y+h); ctx.lineTo(x+c, y+h); ctx.stroke();
    // BR
    ctx.beginPath(); ctx.moveTo(x+w-c, y+h); ctx.lineTo(x+w, y+h); ctx.lineTo(x+w, y+h-c); ctx.stroke();

    // caja de traducción debajo
    const boxY = y + h + 12;
    const boxH = 46;

    ctx.fillStyle = "rgba(0,0,0,0.45)";
    ctx.strokeStyle = ok ? GREEN_SOFT : "rgba(255,190,90,0.55)";
    ctx.lineWidth = 2;
    roundRect(ctx, x, boxY, w, boxH, 12);
    ctx.fill(); ctx.stroke();

    ctx.font = '28px ui-monospace, Menlo, Consolas, monospace';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'top';
    ctx.fillStyle = ok ? GREEN : "rgba(255,220,170,0.95)";
    ctx.shadowColor = 'rgba(0,0,0,0.75)';
    ctx.shadowBlur = 8;
    ctx.fillText(text && text.length ? text : "…", x + w/2, boxY + 8);
    ctx.shadowBlur = 0;
  }

  function drawVideoCoverToFrame() {
    // Dibuja el vídeo en 'frame' con el MISMO comportamiento que object-fit:cover
    const sw = frame.width, sh = frame.height;
    const vw = video.videoWidth, vh = video.videoHeight;
    if (!vw || !vh) return false;

    const scale = Math.max(sw / vw, sh / vh);
    const dw = vw * scale;
    const dh = vh * scale;
    const dx = (sw - dw) / 2;
    const dy = (sh - dh) / 2;

    fctx.clearRect(0,0,sw,sh);
    fctx.drawImage(video, dx, dy, dw, dh);
    return true;
  }

  function preprocessBW(c) {
    const cctx = c.getContext('2d', { willReadFrequently:true });
    const img = cctx.getImageData(0,0,c.width,c.height);
    const d = img.data;
    for (let i=0; i<d.length; i+=4) {
      const lum = 0.2126*d[i] + 0.7152*d[i+1] + 0.0722*d[i+2];
      const v = lum > 150 ? 255 : 0;
      d[i]=d[i+1]=d[i+2]=v;
    }
    cctx.putImageData(img,0,0);
  }

  function cleanBinary(raw) {
    return (raw || "")
      .replace(/[oO]/g,'0')
      .replace(/[iIlL]/g,'1')
      .replace(/[^01 ]/g,'')
      .replace(/\s+/g,' ')
      .trim();
  }

  function binaryToAscii(bin) {
    const bits = bin.replace(/\s+/g,'');
    let out = '';
    for (let i=0; i+8<=bits.length; i+=8) {
      const byte = bits.slice(i, i+8);
      const code = parseInt(byte,2);
      if (code === 32) out += ' ';
      else if (code >= 33 && code <= 126) out += String.fromCharCode(code);
    }
    return out.trim();
  }

  async function initOCR() {
    worker = await Tesseract.createWorker();
    await worker.loadLanguage('eng');
    await worker.initialize('eng');
    await worker.setParameters({
      tessedit_char_whitelist: '01 ',
      preserve_interword_spaces: '1'
    });
  }

  async function scanOnce() {
    if (!stream || busy) return;
    if (!video.videoWidth) return;

    busy = true;
    try {
      const okFrame = drawVideoCoverToFrame();
      if (!okFrame) { busy=false; return; }

      const {x,y,w,h} = roiRect();

      const roi = document.createElement('canvas');
      roi.width = w; roi.height = h;
      roi.getContext('2d').drawImage(frame, x, y, w, h, 0, 0, w, h);

      preprocessBW(roi);

      const { data } = await worker.recognize(roi);
      const bin = cleanBinary(data.text);
      const bitsCount = bin.replace(/\s+/g,'').length;

      if (bitsCount < MIN_BITS) {
        drawUI("…", false);
      } else {
        const txt = binaryToAscii(bin);
        drawUI(txt || "…", !!txt);
      }
    } catch {
      drawUI("…", false);
    } finally {
      busy = false;
    }
  }

  async function start() {
    stream = await navigator.mediaDevices.getUserMedia({
      video: { facingMode: { ideal: "environment" }, width:{ideal:1280}, height:{ideal:720} },
      audio:false
    });
    video.srcObject = stream;

    if (!worker) await initOCR();
    startOverlay.style.display = "none";
    drawUI("…", true);

    if (timer) clearInterval(timer);
    timer = setInterval(scanOnce, SCAN_INTERVAL_MS);
  }

  btnStart.addEventListener('click', start);
</script>
</body>
</html>
